<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Robotic Arm Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #roboticArmContainer {
      width: 100vw;
      height: 100vh;
      display: block;
      background: #eeeeee;
    }
  </style>
</head>
<body>
  <!-- Container for the simulation -->
  <div id="roboticArmContainer"></div>

  <!-- Include Three.js and dat.GUI from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
  <script>
    // Set up scene, camera, and renderer
    const container = document.getElementById('roboticArmContainer');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xeeeeee);
    
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(5, 5, 10);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    
    // Lighting
    scene.add(new THREE.AmbientLight(0x404040));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);
    
    // Create a group to hold the entire robotic arm
    const arm = new THREE.Group();
    scene.add(arm);
    
    // --- Base ---
    const baseGeometry = new THREE.CylinderGeometry(1, 1, 0.5, 32);
    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
    const base = new THREE.Mesh(baseGeometry, baseMaterial);
    arm.add(base);
    
    // --- Lower Arm ---
    const lowerArmGeometry = new THREE.BoxGeometry(0.5, 3, 0.5);
    const lowerArmMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
    const lowerArm = new THREE.Mesh(lowerArmGeometry, lowerArmMaterial);
    // Position the lower arm so its bottom touches the top of the base
    lowerArm.position.y = 1.75;
    base.add(lowerArm);
    
    // --- Upper Arm ---
    const upperArmGeometry = new THREE.BoxGeometry(0.5, 2.5, 0.5);
    const upperArmMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
    const upperArm = new THREE.Mesh(upperArmGeometry, upperArmMaterial);
    // Attach the upper arm to the top of the lower arm.
    // Its position is relative to lowerArm so that its pivot is at its top.
    upperArm.position.y = 1.75;
    // Adjust geometry so rotation occurs from its base
    upperArm.geometry.translate(0, -upperArmGeometry.parameters.height / 2, 0);
    lowerArm.add(upperArm);
    
    // --- Gripper ---
    const gripperGeometry = new THREE.BoxGeometry(0.3, 0.5, 0.3);
    const gripperMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    // Two gripper parts for a simple open/close mechanism
    const gripperLeft = new THREE.Mesh(gripperGeometry, gripperMaterial);
    const gripperRight = new THREE.Mesh(gripperGeometry, gripperMaterial);
    // Position at the bottom of the upper arm
    gripperLeft.position.set(-0.2, -upperArmGeometry.parameters.height, 0);
    gripperRight.position.set(0.2, -upperArmGeometry.parameters.height, 0);
    upperArm.add(gripperLeft);
    upperArm.add(gripperRight);
    
    // --- dat.GUI Controls ---
    const gui = new dat.GUI();
    const controls = {
      baseRotation: 0,
      lowerArmRotation: 0,
      upperArmRotation: 0,
      gripperOpen: 0.2
    };
    
    gui.add(controls, 'baseRotation', -180, 180)
       .name('Base Rotation')
       .onChange(value => { base.rotation.y = THREE.MathUtils.degToRad(value); });
    gui.add(controls, 'lowerArmRotation', -90, 90)
       .name('Lower Arm Rotation')
       .onChange(value => { lowerArm.rotation.z = THREE.MathUtils.degToRad(value); });
    gui.add(controls, 'upperArmRotation', -90, 90)
       .name('Upper Arm Rotation')
       .onChange(value => { upperArm.rotation.z = THREE.MathUtils.degToRad(value); });
    gui.add(controls, 'gripperOpen', 0, 1)
       .name('Gripper Open')
       .onChange(value => {
          gripperLeft.position.x = -0.2 - value;
          gripperRight.position.x = 0.2 + value;
       });
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
